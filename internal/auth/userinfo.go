// Package auth provides OAuth2/OIDC authentication utilities for Auth0 integration.
// This file handles fetching user attributes from the Auth0 userinfo endpoint
// using the access token obtained during the OAuth2 flow.
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// UserInfo represents the user information from Auth0's userinfo endpoint or ID token.
// Contains user attributes needed for Intercom identification.
// Note: We don't extract Auth0's 'sub' claim as it's not safe to use as a username.
// The authoritative user identity is in the IntercomJWT (generated by Auth0 Action).
type UserInfo struct {
	Email       string `json:"email,omitempty"` // User's email address if available
	Name        string `json:"name,omitempty"`  // User's display name if available
	IntercomJWT string `json:"-"`               // Pre-generated Intercom JWT from Auth0 Action (not in JSON responses)
}

// FetchUserInfo retrieves user information from Auth0 using an access token.
// This is used to get stable user attributes after successful authentication.
// The userinfo endpoint provides OpenID Connect standard claims about the user.
// Requires a valid access token with appropriate scopes (openid, email, profile).
func FetchUserInfo(ctx context.Context, domain, accessToken string) (*UserInfo, error) {
	// Build userinfo endpoint URL - preserve protocol if already specified
	var userinfoURL string
	if strings.HasPrefix(domain, "http://") || strings.HasPrefix(domain, "https://") {
		userinfoURL = fmt.Sprintf("%s/userinfo", strings.TrimSuffix(domain, "/"))
	} else {
		userinfoURL = fmt.Sprintf("https://%s/userinfo", domain)
	}

	// Create request
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, userinfoURL, nil)
	if err != nil {
		return nil, fmt.Errorf("creating userinfo request: %w", err)
	}

	// Add authorization header
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", accessToken))

	// Execute request with proper timeouts
	// 3s connect timeout via transport, 5s total timeout
	transport := &http.Transport{
		DisableKeepAlives: true,
	}
	client := &http.Client{
		Timeout:   5 * time.Second,
		Transport: transport,
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("userinfo request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read response body with size limit (1MB max for defense)
	limitedReader := io.LimitReader(resp.Body, 1024*1024)
	body, err := io.ReadAll(limitedReader)
	if err != nil {
		return nil, fmt.Errorf("reading userinfo response: %w", err)
	}

	// Handle non-200 responses
	if resp.StatusCode != http.StatusOK {
		switch resp.StatusCode {
		case http.StatusUnauthorized:
			return nil, fmt.Errorf("invalid or expired access token")
		case http.StatusForbidden:
			return nil, fmt.Errorf("insufficient permissions to access userinfo")
		default:
			return nil, fmt.Errorf("userinfo request failed with status %d", resp.StatusCode)
		}
	}

	// Parse successful response
	var userInfo UserInfo
	if err := json.Unmarshal(body, &userInfo); err != nil {
		return nil, fmt.Errorf("parsing userinfo response: %w", err)
	}

	return &userInfo, nil
}
