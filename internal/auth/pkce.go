// Package auth provides OAuth2/OIDC authentication utilities including
// PKCE (Proof Key for Code Exchange) implementation per RFC 7636.
//
// # PKCE Overview
//
// PKCE enhances the OAuth2 authorization code flow security for public clients
// by using cryptographically random secrets to prevent authorization code
// interception attacks. This is especially important for mobile apps and SPAs.
//
// # Security Implementation
//
// Code Verifier: Cryptographically random string (32-96 bytes) encoded as
// base64url without padding. Must be 43-128 characters after encoding per RFC 7636.
//
// Code Challenge: SHA256 hash of the code verifier, encoded as base64url
// without padding. Uses the "S256" method as recommended by RFC 7636.
//
// Nonce: Random value for OpenID Connect to prevent replay attacks.
// Minimum 16 bytes recommended for sufficient entropy.
//
// # Usage
//
// Generate PKCE parameters for OAuth2 flow:
//   verifier, err := NewCodeVerifier(32)  // 32 bytes = 43 chars encoded
//   challenge, err := CodeChallengeS256(verifier)
//   nonce, err := NewNonce(16)  // 16 bytes = 22 chars encoded
package auth

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"fmt"
)

// RFC 7636 defines code_verifier length constraints after base64url encoding
const (
	MinCodeVerifierBytes = 32  // Results in 43 characters after base64url encoding
	MaxCodeVerifierBytes = 96  // Results in 128 characters after base64url encoding
	MinNonceBytes        = 16  // Minimum recommended for sufficient entropy
	MaxNonceBytes        = 64  // Reasonable upper limit
)

// NewCodeVerifier generates a cryptographically secure random code verifier
// for PKCE (Proof Key for Code Exchange) per RFC 7636.
//
// The nBytes parameter specifies the number of random bytes to generate.
// Valid range is 32-96 bytes, which results in 43-128 characters after
// base64url encoding as required by RFC 7636.
//
// Returns a base64url-encoded string without padding.
func NewCodeVerifier(nBytes int) (string, error) {
	if nBytes < MinCodeVerifierBytes {
		return "", fmt.Errorf("code verifier must be at least %d bytes (got %d)", MinCodeVerifierBytes, nBytes)
	}
	if nBytes > MaxCodeVerifierBytes {
		return "", fmt.Errorf("code verifier must be at most %d bytes (got %d)", MaxCodeVerifierBytes, nBytes)
	}

	// Generate cryptographically secure random bytes
	randomBytes := make([]byte, nBytes)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}

	// Encode as base64url without padding
	verifier := base64.RawURLEncoding.EncodeToString(randomBytes)

	// Verify the encoded length meets RFC 7636 requirements
	if len(verifier) < 43 || len(verifier) > 128 {
		return "", fmt.Errorf("encoded verifier length %d outside RFC 7636 range 43-128", len(verifier))
	}

	return verifier, nil
}

// CodeChallengeS256 creates a code challenge from a code verifier using
// the S256 method (SHA256) as specified in RFC 7636.
//
// The verifier must be a valid base64url-encoded string between 43-128
// characters as generated by NewCodeVerifier.
//
// Returns a base64url-encoded SHA256 hash without padding.
func CodeChallengeS256(verifier string) (string, error) {
	if verifier == "" {
		return "", errors.New("code verifier cannot be empty")
	}

	// Validate verifier length per RFC 7636
	if len(verifier) < 43 {
		return "", fmt.Errorf("code verifier too short: %d characters (minimum 43)", len(verifier))
	}
	if len(verifier) > 128 {
		return "", fmt.Errorf("code verifier too long: %d characters (maximum 128)", len(verifier))
	}

	// Validate that verifier is valid base64url (no padding allowed)
	if _, err := base64.RawURLEncoding.DecodeString(verifier); err != nil {
		return "", fmt.Errorf("invalid code verifier format: %w", err)
	}

	// Compute SHA256 hash
	hash := sha256.Sum256([]byte(verifier))

	// Encode as base64url without padding
	challenge := base64.RawURLEncoding.EncodeToString(hash[:])

	return challenge, nil
}

// NewNonce generates a cryptographically secure random nonce for OpenID Connect.
//
// The nBytes parameter specifies the number of random bytes to generate.
// Valid range is 16-64 bytes. 16 bytes provides sufficient entropy for
// most use cases, while 32 bytes provides extra security margin.
//
// Returns a base64url-encoded string without padding.
func NewNonce(nBytes int) (string, error) {
	if nBytes < MinNonceBytes {
		return "", fmt.Errorf("nonce must be at least %d bytes (got %d)", MinNonceBytes, nBytes)
	}
	if nBytes > MaxNonceBytes {
		return "", fmt.Errorf("nonce must be at most %d bytes (got %d)", MaxNonceBytes, nBytes)
	}

	// Generate cryptographically secure random bytes
	randomBytes := make([]byte, nBytes)
	if _, err := rand.Read(randomBytes); err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}

	// Encode as base64url without padding
	nonce := base64.RawURLEncoding.EncodeToString(randomBytes)

	return nonce, nil
}